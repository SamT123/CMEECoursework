Starting weekly assessment for Sam, Week7

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 26.80 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week6, Week1, Week7, MP, Assessment, HPC, Week5, Week2, Week4, .git, Week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*.tmp
*.DS_store
*.pyc
__pycache__
*.RHistory
.idea
.vscode
Rplots.pdf
.log
*.log**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# **2019-20 CMEE Coursework Repository**
## About
Author: Sam Turner

Repository for my CMEE coursework. The directory for each Week contains four subdirectories: **code**, **data**, **results** (empty, populated when scripts from code are run), and **sandbox** (code and data used in development).

Dependencies for each Week are specified in the README in the Week's subdirectory.

## Contents
### [Week 1](https://github.com/SamT123/CMEECoursework/tree/master/Week1)
* UNIX
* Shell scripting
* LaTex

### [Week 2](https://github.com/SamT123/CMEECoursework/tree/master/Week2)
* Python I

### [Week 3](https://github.com/SamT123/CMEECoursework/tree/master/Week3)
* R

### [Week 4](https://github.com/SamT123/CMEECoursework/tree/master/Week4)
* Stats

### [Week 5](https://github.com/SamT123/CMEECoursework/tree/master/Week5)
* Stats
* GIS

### [Week 6](https://github.com/SamT123/CMEECoursework/tree/master/Week6)
* Genomics and Bioinformatics

### [Week 7](https://github.com/SamT123/CMEECoursework/tree/master/Week7)
* Python II

## Prerequisites
### Python 3.x
`pickle`	`stringdist`
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 7 weekly directories: Week1, Week2, Week3, Week4, Week5, Week6, Week7

The Week7 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK7...

Found the following directories: Code, sandbox, Data, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Week 7
Coursework for CMEE week 7.
## Topics:
* Python II

## Requirements:
* `Python 3.7`
* `R 3.6`
* `NumPy`
* `Pandas`
* `networkx`
* `igraph`
* `matplotlib`
* `cProfile`
* `pstats`
* `regex`
* `scipy`

## Contents
### [Code](https://github.com/SamT123/CMEECoursework/tree/master/Week7/Code)
**blackbirds.py**
* Solution to regex practical, extracting Kingdom, Phylum, and Species information from text file

**DrawFW.py**
* Program generating random food web

**fmr.R**
* Plots log(field metabolic rate) against log(body size) and fits linear model for Nagy 1999 dataset

**run_fmr_R.py**
* Run fmr.R from python using a subprocess


**LV1.py**
* Solves basic Lotka Volterra model by numerical integration, outputting final population sizes and graphs of:
    * Consumer vs Producer population sizes
    * Consumer and Producer population size vs time

**LV2.py**
* Solves Lotka Volterra model with prey density dependence by numerical integration. Takes parameter values from command line (r, a, z, e), or if absent, uses defaults giving stable final population sizes. Outputs final population sizes and graphs of:
    * Consumer vs Producer population sizes
    * Consumer and Producer population size vs time
* Example usage:
`python3 LV2.py 1.0 0.1 0.70 0.75`

**LV3.py**
* Solves discrete time Lotka Volterra model with parameters R0, C0, K, r, a, z, e passed from command line. If absent, default parameter values are used. Outputs final population sizes and graphs of:
    * Consumer vs Producer population sizes
    * Consumer and Producer population size vs time
* Example usage:
`python3 LV3.py 5 10 20 1.0 0.1 0.70 0.75 100`

**LV4.py**
* Solves discrete time Lotka Volterra model with random Gaussian fluctuation with parameters R0, C0, K, r, a, z, e passed from command line. If absent, default parameter values are used. Outputs final population sizes and graphs of:
    * Consumer vs Producer population sizes
    * Consumer and Producer population size vs time
* Example usage:
`python3 LV4.py 5 10 20 1.0 0.1 0.70 0.75 100`

**run_Lv.py**
* Runs and profiles all of LV1.py, LV2.py, LV3.py, LV4.py. Shows profile of top 20 calls by tottime.

**Nets.py**
* Makes graphs representing QMEE collaboration netwrok, with Node size representing number of collaborators within institution and 
edge width representing number of collaborations between institutions.

**Nets.R**
* Makes graphs representing QMEE collaboration netwrok, with Node size representing number of members within institution and 
edge width representing number of collaborations between institutions.

**profileme.py**
* Squaring and string concatenation functions inefficiently implemented to demonstrate optimization.
    * Squaring: uses for loop
    * Str conc: uses .join() method

**profileme2.py**
* Squaring and string concatenation functions more efficiently implemented.
    * Squaring: list comprehension
    * Str conc: direct str + str concatenation

**profileme_np.py**
* Squaring and string concatenation functions inefficiently implemented to demonstrate optimization.
    * Squaring: numpy array operations
    * Str conc: direct str + str concatenation


**timeitme.py**
* Times functions in profileme* scripts to show benefits of optimization

**regex.py**
* Script from regex lectures

**TestR.R**
* Test script to demonstrate subprocess

**using_os.py**
* Directory walking exercises



### [Data](https://github.com/SamT123/CMEECoursework/tree/master/Week7/Data)
**blackbirds.txt**
* Text file with phylogeny data for balckbird species.

**NagyEtAl1999**
* Field metabolic rate and body size data from Nagy et al. 1999.

**QMEE_Net_Mat_edges.csv**
* Pairwise number of collaborations data for QMEE institutions.

**QMEE_Net_Mat_nodes.csv**
* Number of members data for QMEE institutions.


### [Results](https://github.com/SamT123/CMEECoursework/tree/master/Week7/Results)
**********************************************************************

Found following files in results directory: LV2_model_C_vs_R.pdf, fmr_plot.pdf, FoodWeb.pdf, LV1_C_vs_R.pdf, LV3_model_vs_t.pdf, LV2_model_vs_t.pdf, README.md, LV4_model_vs_t.pdf, QMEENet.svg, LV1_time.pdf, LV4_model_C_vs_R.pdf, LV3_model_C_vs_R.pdf...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 19 code files: TestR.py, LV3.py, profileme2.py, timeitme.py, blackbirds.py, profileme_np.py, regex.py, Nets.py, TestR.R, profileme.py, LV4.py, fmr.R, using_os.py, LV1.py, DrawFW.py, Nets.R, run_fmr_R.py, run_LV.py, LV2.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TestR.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Runs the TestR.R script as a subprocess """


__appname__ = 'TestR.py'
__author__  = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import subprocess

subprocess.Popen("Rscript --verbose TestR.R > ../Results/TestR.Rout 2> ../Results/TestR_errFile.Rout", shell=True).wait()**********************************************************************

Testing TestR.py...

TestR.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.13338s

======================================================================
Inspecting script file LV3.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Program to simulate discrete time Lotka-Volterra model with parameter values passed from command line.

INPUTS:
    R0  =   initial resource population size
    C0  =   initial consumer population size
    K   =   resource carrying capacity
    r   =   intrinsic growth rate
    a   =   per capita search rate * attack success probability
    z   =   mortality rate
    e   =   consumer effciency
    gens=   number of generations to run model for

OUTPUTS:
    ../Results/LV3_C_vs_R.pdf   =   Counsumer and Resource popn sizes vs time
    ../Results/LV3_time.pdf     =   Consumer vs Resource population size plot
"""

__appname__ = 'LV3.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports
import sys
import numpy as np
import matplotlib.pylab as p

def main(args):
    """ Main entry point for program.
    
    PARAMETERS
    ----------
    args : list
        list of parameters passed from command line
        
    RETURNS
    -------
    0 or 1
        0 if successful, 1 otherwise """
    numeric_args = check_args(args)

    if numeric_args == 1:
        return 1



    global R0, C0, K, r, a, z, e,  gens
    R0, C0, K, r, a, z, e,  gens = numeric_args
    gens = int(gens)


    densities = np.zeros([gens,2])
    densities[0] =  np.array([R0,C0])
    densities = simulate(densities)
    make_plots(densities)
    return 0


def simulate(densities):
    """
    Runs discrete time LV model using paramters specified as globals in main()
    
    PARAMTERS
    ---------
    densities : array
        array of initial population densities [R0, C0]
    
    RETURNS
    -------
    array
        2D array of resource and consumer densities at each timestep
    """
    zero_pop = False
    for gen in range(1,gens):
        R = densities[gen-1][0]
        C = densities[gen-1][1]
        densities[gen][0] = R * (1 + r * ( 1 - R / K) - a * C)
        densities[gen][1] = C * (1 - z + e * a * R)


        if densities[gen][0] < 0.:
            densities[gen][0] = 0.
            zero_pop = True

        if densities[gen][1] < 0.:
            densities[gen][1] = 0.
            zero_pop = True

        if zero_pop:
            print("A population reached zero density")
            return densities

    return densities


def make_plots(pops):
    """
    Make and save plots of population size vs time, and Consumer population size vs Resource population size

    PARAMETERS
    ----------
    pops : array
        array of population densities at each timestep

    RETURNS
    -------
    None

    """
    t = range(len(pops))

    f1 = p.figure()
    p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
    p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
    p.grid()
    p.legend(loc='best')
    # vairable position required for text:
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e),  x = gens*0.83, y = max(pops.ravel())*0.7,  bbox=dict(facecolor='white', edgecolor='black',alpha=0.5))
    p.xlabel('Time')
    p.ylabel('Population density')
    p.title('C-R population dynamics - discrete time LV Model')
    f1.savefig('../Results/LV3_model_vs_t.pdf') #Save figure 


    f2 = p.figure()
    p.plot(pops[:,0], pops[:,1]  , 'r-')
    p.grid()
    # vairable position required for text:
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e), x = max(pops[:,0])-(max(pops[:,0])-min(pops[:,0]))*0.2, y = max(pops[:,1])-(max(pops[:,1])-min(pops[:,1]))*0.2,  bbox=dict(facecolor='white', edgecolor='black',alpha=0.5))
    p.xlabel('Resource density')
    p.ylabel('Consumer density')
    p.title('C-R population dynamics - discrete time Lotka Volterra Model')
    f2.savefig('../Results/LV3_model_C_vs_R.pdf') #Save figure 


    print("Final resource density = \t{}\nFinal consumer density = \t{}".format(pops[-1][0],pops[-1][1]))
    return


def check_args(args):
    """
    Check if arguments passed from command line are 4 numeric values
    PARAMETERS
    ----------
    args : list
        list of command line parameters


    RETURNS
    -------
    list or 1
        list of float parameter values if no error occurred; otherwise 1
    """
    if len(args) == 0:
        print("Using default parameter values: R0 = 5, C0 = 10, K = 20, r = 1, a = 0.1, z = 0.70, e = 0.75, gens = 100")
        return [5, 10, 20, 1.0, 0.1, 0.70, 0.75,100]

    if len(args) != 8:
        print("Please provide 8 parameter values: R0, C0, K, r, a, z, e,  gens")
        return 1


    try:
        numeric_list = list(map(float, args))
        return numeric_list
    except:
        print("Please provide 8 numeric arguments: R0, C0, K, r, a, z, e,  gens.")
        return 1

    return

if __name__ == '__main__':
    status = main(sys.argv[1:])
    sys.exit(status)**********************************************************************

Testing LV3.py...

LV3.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Using default parameter values: R0 = 5, C0 = 10, K = 20, r = 1, a = 0.1, z = 0.70, e = 0.75, gens = 100
Final resource density = 	9.346397848538722
Final consumer density = 	5.35330457341212

**********************************************************************

Code ran without errors

Time consumed = 0.72888s

======================================================================
Inspecting script file profileme2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Script containing functions producing square numbers and concatenated strings to demonstrate code profiling and optimisation.
They are implemented with list comprehension and direct str + str concatention respectively, which is faster than the 
solutions in profileme.py
"""
__appname__ = 'profileme2.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

def my_squares(iters):
    """
    Calculate all square numbers for 1 to n using list comprehension
    PARAMETERS
    ----------
    iters : int
        number of squares we want to calculate
    RETURNS
    -------
    list
        squared values of arguement iters
    """ 
    out = [i ** 2 for i in range(iters)]
    return out

def my_join(iters, string):
    """
    Join string n times, separated by ', ' using direct string concatenation

    PARAMETERS
    ----------
    iters : int
        number of copies of the string to be joined
    string : str
        string to join

    RETURNS
    -------
    str
        joined string
    """
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    """
    Run my_squares and my_join, for the purpose of profiling

    PARAMETERS
    ----------
    x : iters
        the number of iterations for my_squares and my_join
    y : str
        string to pass to my_join

    RETURNS
    -------
    0
    """
    print("iters: " + str(x) + ", str: " + str(y))
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme2.py...

profileme2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
iters: 10000000, str: My string

**********************************************************************

Code ran without errors

Time consumed = 3.67077s

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Script timing functions for producing squares and concatenated strings, to demonstrate code optimization"""


__appname__ = 'profileme_np.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

##############################################################################
# loops vs. list comprehensions vs numpy: which is faster?
##############################################################################


# imports for squares

iters = 1000000

import timeit
import time

from profileme import my_squares as my_squares_loops

from profileme2 import my_squares as my_squares_lc

from profileme_np import my_squares as my_squares_np

# Loop timing

print("Squares\n-------")

start = time.time()
my_squares_loops(iters);
t = (time.time() - start)
print("\tLoops:\t{}".format(t))

# List comprehension timing

start = time.time()
my_squares_lc(iters);
t = (time.time() - start)
print("\tlc:\t{}".format(t))

# Numpy timing

start = time.time()
my_squares_np(iters);
t = (time.time() - start)
print("\tNumpy:\t{}".format(t))

# %timeit my_squares_loops(iters)
# %timeit my_squares_lc(iters)


##############################################################################
# loops vs. the join method for strings: which is faster?
##############################################################################

# imports for string joining

mystring = "my string"

from profileme import my_join as my_join_join

from profileme2 import my_join as my_join



print("Strings\n-------")

start = time.time()
my_join_join(iters, mystring);
t = (time.time() - start)
print("\tjoin:\t{}".format(t))

# List comprehension timing

start = time.time()
my_join(iters,mystring);
t = (time.time() - start)
print("\tConcat:\t{}".format(t))
# %timeit(my_join_join(iters, mystring))
# %timeit(my_join(iters, mystring))**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 10.00386s

======================================================================
Inspecting script file blackbirds.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Script to extract Kingdom, Phylum, Species for blackbirds from blackbirds.txt file """

__appname__ = 'blackbirds.py'
__author__  = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports
import re

# Read the file (using a different, more python 3 way, just for fun!)
with open('../Data/blackbirds.txt', 'r') as f:
    text = f.read()

# replace \t's and \n's with a spaces:
text = text.replace('\t',' ')
text = text.replace('\n',' ')
# You may want to make other changes to the text. 
  
# In particular, note that there are "strange characters" (these are accents and
# non-ascii symbols) because we don't care for them, first transform to ASCII:

text = text.encode('ascii', 'ignore') # first encode into ascii bytes
text = text.decode('ascii', 'ignore') # Now decode back to string

# Now extend this script so that it captures the Kingdom, Phylum and Species
# name for each species and prints it out to screen neatly.
pattern = r'Kingdom\s(\w+)\s.*?Phylum\s(\w+)\s.*?Species\s(\w+\s\w+)'
individuals = re.findall(pattern, text)


print("\nKINGDOM\t\tPHYLUM\t\tSPECIES\n")

for ind in individuals:
    print('\t'.join(ind) )
# Hint: you may want to use re.findall(my_reg, text)... Keep in mind that there
# are multiple ways to skin this cat! Your solution could involve multiple
# regular expression calls (easier!), or a single one (harder!)**********************************************************************

Testing blackbirds.py...

blackbirds.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

KINGDOM		PHYLUM		SPECIES

Animalia	Chordata	Euphagus carolinus
Animalia	Chordata	Euphagus cyanocephalus
Animalia	Chordata	Turdus boulboul
Animalia	Chordata	Agelaius assimilis

**********************************************************************

Code ran without errors

Time consumed = 0.03027s

======================================================================
Inspecting script file profileme_np.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Script containing functions producing square numbers and concatenated strings to demonstrate code profiling and optimisation.
The squares function is implemented using numpy array operations, which are faster than list comprehensions of a for loop.
"""

__appname__ = 'profileme_np.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import numpy as np

def my_squares(iters):
    """
    Calculate all square numbers for 1 to n using numpy array operations
    PARAMETERS
    ----------
    iters : int
        number of squares we want to calculate
    RETURNS
    -------
    list
        squared values of arguement iters
    """ 
    out = np.arange(iters)
    out = out**2
    return out


def my_join(iters, string):
    """
    Join string n times, separated by ', ' using direct string concatenation

    PARAMETERS
    ----------
    iters : int
        number of copies of the string to be joined
    string : str
        string to join

    RETURNS
    -------
    str
        joined string
    """
    out = ''
    for i in range(iters):
        out += ", " + string
    return out

def run_my_funcs(x,y):
    """
    Run my_squares and my_join, for the purpose of profiling

    PARAMETERS
    ----------
    x : iters
        the number of iterations for my_squares and my_join
    y : str
        string to pass to my_join

    RETURNS
    -------
    0
    """
    print("iters: " + str(x) + ", str: " + str(y))
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")**********************************************************************

Testing profileme_np.py...

profileme_np.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
iters: 10000000, str: My string

**********************************************************************

Code ran without errors

Time consumed = 1.31891s

======================================================================
Inspecting script file regex.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""regex notes from lectures"""

__appname__ = 'regex.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import re
import pandas as pd 


my_string = "a given string"

match = re.search(r'\s', my_string)
print(match)
#match.group()

match = re.search(r'\d', my_string)
print(match)

MyStr = 'an example'

match = re.search(r'\w*\s', MyStr) # what pattern is this?

if match:                      
    print('found a match:', match.group()) 
else:
    print('did not find a match')

match = re.search(r'2' , "it takes 2 to tango")
match.group()

match = re.search(r'\d' , "it takes 2 to tango")
match.group()

match = re.search(r'\d.*' , "it takes 2 to tango")
match.group()

match = re.search(r'\s\w{1,3}\s', 'once upon a time')
match.group()

match = re.search(r'\s\w*$', 'once upon a time')
match.group()

re.search(r'\w*\s\d.*\d', 'take 2 grams of H2O').group()


re.search(r'^\w*.*\s', 'once upon a time').group() 

re.search(r'^\w*.*?\s', 'once upon a time').group()

re.search(r'<.+>', 'This is a <EM>first</EM> test').group()

re.search(r'<.+?>', 'This is a <EM>first</EM> test').group()

re.search(r'\d*\.?\d*','1432.75+60.22i').group()

re.search(r'[AGTC]+', 'the sequence ATTCGT').group()

re.search(r'\s+[A-Z]\w+\s*\w+', "The bird-shit frog's name is Theloderma asper.").group()

re.search(r'[\w\s]+', "Sam Tu?rner").group()

#re.search(r'^abc[ab]+\s\t\d', "abcabacbcaba \t2").group()

re.search(r'\s*[a-zA-Z,\s]+\s*', '     gxzDFS,, ghd ,h GIKL       ').group()

#YYYYMMDD
re.search(r'(19\d{2}|2\d{3})[01]\d[0123]\d', '19080224').group()

MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a-academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a_academic@imperial.ac.uk, Some other stuff thats even more boring"


emails = re.findall(r'[\w\.-]+@[\w\.-]+', MyStr) 
for email in emails:
    print(email)

f = open('../../Week2/Data/TestOaksData.csv', 'r')
found_oaks = re.findall(r"Q[\w\s].*\s", f.read())

found_oaks

MyStr = "Samraat Pawar, s.pawar@imperial.ac.uk, Systems biology and ecological theory; Another academic, a.academic@imperial.ac.uk, Some other stuff thats equally boring; Yet another academic, y.a.academic@imperial.ac.uk, Some other stuff thats even more boring"

found_matches = re.findall(r"([\w\s]+),\s([\w\.-]+@[\w\.-]+)", MyStr)
found_matches

for item in found_matches:
    print(item)

# text from webpages
import urllib3

conn = urllib3.PoolManager() # open a connection
r = conn.request('GET', 'https://www.imperial.ac.uk/silwood-park/academic-staff/') 
webpage_html = r.data #read in the webpage's contents

My_Data  = webpage_html.decode()
#print(My_Data)

pattern = r"(Dr|Prof)\s+([\w']+)\s+([\w']+)"
regex = re.compile(pattern) # example use of re.compile(); you can also ignore case  with re.IGNORECASE
matches = re.findall(pattern,My_Data)
matches_unique = {' '.join(n) for n in matches}
for match in regex.finditer(My_Data): # example use of re.finditer()
    print(match.group())
    



**********************************************************************

Testing regex.py...

regex.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
<_sre.SRE_Match object; span=(1, 2), match=' '>
None
found a match: an 
s.pawar@imperial.ac.uk
a-academic@imperial.ac.uk
y.a_academic@imperial.ac.uk
('Samraat Pawar', 's.pawar@imperial.ac.uk')
(' Another academic', 'a.academic@imperial.ac.uk')
(' Yet another academic', 'y.a.academic@imperial.ac.uk')
Dr Arkhat Abzhanov
Dr Arkhat Abzhanov
Dr Cristina Banks
Dr Martin Bidartondo
Dr Martin Brazeau
Dr Lauren Cator
Dr Rob Ewers
Dr Rob Ewers
Dr Rob Ewers
Dr Matteo Fumagalli
Dr Richard Gill
Dr Richard Gil
**********************************************************************

Code ran without errors

Time consumed = 0.78207s

======================================================================
Inspecting script file Nets.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Script to make graph for QMEE collaboration network. Edge width represents number of collaborations, node colour represents
institution type.

INPUTS:
    None

OUTPUTS:
    ../Results/QMEENet_python.svg.pdf   =   network representing QMEE collaboration network
    
"""

__appname__ = 'Nets.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import numpy as np
import pandas as pd
import itertools
import networkx as nx
import matplotlib.pylab as p
import math
import matplotlib.patches as mpatches

# load edges and nodes
edges = pd.read_csv("../Data/QMEE_Net_Mat_edges.csv", header=0)
edges.index = edges.columns
nodes = pd.read_csv("../Data/QMEE_Net_Mat_nodes.csv", header=0,index_col=0) 

# adjacency list
AdjL = []
for inst1,inst2 in itertools.product(edges.index, edges.columns):
    if edges.loc[inst1, inst2] > 0:
        AdjL.append((inst1,inst2,edges.loc[inst1, inst2]))


# nodes list
sps = nodes.index.to_list()

# sizes
sizeL = nodes['Pis']

# colours for legend
conv = {'University':'green','Hosting Partner':'red','Non-Hosting Partners':'blue'}
collist = [conv[ty] for ty in nodes['Type'].to_list()]

red_patch = mpatches.Patch(color='red', label='Hosting Partner')
green_patch = mpatches.Patch(color='green', label='University')
blue_patch = mpatches.Patch(color='blue', label='Non-Hosting Partner')


# get positions
pos = nx.circular_layout(sps)


# Initialise graph, add edges to graph, and produce list of edge weights
ws=np.array([])

G = nx.Graph()
G.add_nodes_from(sps)

for l in AdjL:
     G.add_edges_from([(l[0], l[1])])
     ws=np.append(ws,l[2])


ws = np.log(ws) * 2

# calculate node sizes
NodSizs= 2000 * (1+sizeL-min(sizeL))/(1+max(sizeL)-min(sizeL))

# draw network
nx.draw_networkx(G, pos, width=ws,node_size= NodSizs,edge_color='grey', arrows = True, node_color=collist)
p.legend(handles=[red_patch,green_patch,blue_patch], loc = [0,0.7])


#save network
print("Saving network to ../Results/QMEENet_python.svg")
p.savefig("../Results/QMEENet_python.svg", format = "svg")**********************************************************************

Testing Nets.py...

Nets.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "Nets.py", line 43, in <module>
    sps = nodes.index.to_list()
AttributeError: 'Index' object has no attribute 'to_list'

======================================================================
Inspecting script file TestR.R...

File contents are:
**********************************************************************
print("Hello, this is R!")
**********************************************************************

Testing TestR.R...

Output (only first 500 characters): 

**********************************************************************
[1] "Hello, this is R!"

**********************************************************************

Code ran without errors

Time consumed = 0.09680s

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Script containing functions producing square numbers and concatenated strings to demonstrate code profiling and optimisation.
They are implemented with a for loop and the .join() string method respectively.

"""

__appname__ = 'profileme.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

def my_squares(iters):
    """
    Calculate all square numbers for 1 to n using iteration
    PARAMETERS
    ----------
    iters : int
        number of squares we want to calculate
    RETURNS
    -------
    list
        squared values of arguement iters
    """
    out = []
    for i in range(iters):
        out.append(i ** 2)
    return out

def my_join(iters, string):
    """
    Join string n times, separated by ', ' using str.join() method

    PARAMETERS
    ----------
    iters : int
        number of copies of the string to be joined
    string : str
        string to join

    RETURNS
    -------
    str
        joined string
    """
    out = ''
    for i in range(iters):
        out += string.join(", ")
    return out

def run_my_funcs(x,y):
    """
    Run my_squares and my_join, for the purpose of profiling

    PARAMETERS
    ----------
    x : iters
        the number of iterations for my_squares and my_join
    y : str
        string to pass to my_join

    RETURNS
    -------
    0
    """
    print("iters: " + str(x) + ", str: " + str(y))
    my_squares(x)
    my_join(x,y)
    return 0

run_my_funcs(10000000,"My string")
**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
iters: 10000000, str: My string

**********************************************************************

Code ran without errors

Time consumed = 6.45070s

======================================================================
Inspecting script file LV4.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Program to simulate discrete time Lotka-Volterra model with paramterter values passed from command line, with random Gaussian fluctuation in both population size each generation.

INPUTS:
    R0  =   initial resource population size
    C0  =   initial consumer population size
    K   =   resource carrying capacity
    r   =   intrinsic growth rate
    a   =   per capita search rate * attack success probability
    z   =   mortality rate
    e   =   consumer effciency
    gens=   number of generations to run model for

OUTPUTS:
    ../Results/LV3_C_vs_R.pdf   =   Counsumer and Resource popn sizes vs time
    ../Results/LV3_time.pdf     =   Consumer vs Resource population size plot
    """

__appname__ = 'LV4.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports
import sys
import numpy as np
import matplotlib.pylab as p

def main(args):
    """
    Main entry point for program.
    
    PARAMETERS
    ----------
    args : list
        list of parameters passed from command line
        
    RETURNS
    -------
    0 or 1
        0 if successful, 1 otherwise
    """
    numeric_args = check_args(args)

    if numeric_args == 1:
        return 1



    global R0, C0, K, r, a, z, e,  gens
    R0, C0, K, r, a, z, e,  gens = numeric_args
    gens = int(gens)
    densities = np.zeros([gens,2])
    densities[0] =  np.array([R0,C0])
    densities = simulate(densities)
    make_plots(densities)
    return 0


def simulate(densities):
    """
    Runs discrete time LV model with Gaussian fluctuations using paramters specified as globals in main()
    
    PARAMTERS
    ---------
    densities : array
        array of initial population densities [R0, C0]
    
    RETURNS
    -------
    array
        2D array of resource and consumer densities at each timestep
    """
    zero_pop = False
    fluctuations = np.random.randn(gens-1,2)/10
    for gen in range(1,gens):
        R = densities[gen-1][0]
        C = densities[gen-1][1]
        densities[gen][0] = R * (1 + (r + fluctuations[gen-1,0]) * (1 - R / K) - a * C)
        densities[gen][1] = C * (1 - z + e * a * R + fluctuations[gen-1,1])

        if densities[gen][0] < 0.:
            densities[gen][0] = 0.
            zero_pop = True

        if densities[gen][1] < 0.:
            densities[gen][1] = 0.
            zero_pop = True

        if zero_pop:
            print("A population reached zero density")
            return densities


    return densities


def make_plots(pops):
    """
    Make and save plots of population size vs time, and Consumer population size vs Resource population size

    PARAMETERS
    ----------
    pops : array
        array of population sizes at each timestep

    RETURNS
    -------
    None

    """
    t = range(len(pops))

    f1 = p.figure()
    p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
    p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
    p.grid()
    p.legend(loc='upper right')
    # vairable position required for text:
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e),  x = gens*0.83, y = max(pops.ravel())*0.7,  bbox=dict(facecolor='white', edgecolor='black',alpha=0.7))

    p.xlabel('Time')
    p.ylabel('Population density')
    p.title('C-R population dynamics - discrete time LV with popn. fluctuation')
    f1.savefig('../Results/LV4_model_vs_t.pdf') #Save figure 


    f2 = p.figure()
    p.plot(pops[:,0], pops[:,1]  , 'r-')
    p.grid()
    # vairable position required for text:
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e), x = max(pops[:,0])-(max(pops[:,0])-min(pops[:,0]))*0.2, y = max(pops[:,1])-(max(pops[:,1])-min(pops[:,1]))*0.2,  bbox=dict(facecolor='white', edgecolor='black',alpha=0.5))

    p.xlabel('Resource density')
    p.ylabel('Consumer density')
    p.title('C-R population dynamics - discrete time LV with popn. fluctuation')
    f2.savefig('../Results/LV4_model_C_vs_R.pdf') #Save figure 


    print("Final resource density = \t{}\nFinal consumer density = \t{}".format(pops[-1][0],pops[-1][1]))
    return



def check_args(args):
    """
    Check if arguments passed from command line are 4 numeric values
    PARAMETERS
    ----------
    args : list
        list of command line parameters


    RETURNS
    -------
    list or 1
        list of float parameter values if no error occurred; otherwise 1
    """
    if len(args) == 0:
        print("Using default parameter values: R0 = 5, C0 = 10, K = 20, r = 1, a = 0.1, z = 0.70, e = 0.75, gens = 100")
        return [5, 10, 20, 1.0, 0.1, 0.70, 0.75,100]

    if len(args) != 8:
        print("Please provide 8 parameter values: R0, C0, K, r, a, z, e,  gens")
        return 1


    try:
        numeric_list = list(map(float, args))
        return numeric_list
    except:
        print("Please provide 8 numeric arguments: R0, C0, K, r, a, z, e,  gens.")
        return 1

    return



if __name__ == '__main__':
    status = main(list(map(float, sys.argv[1:])))
    sys.exit(status)**********************************************************************

Testing LV4.py...

LV4.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Using default parameter values: R0 = 5, C0 = 10, K = 20, r = 1, a = 0.1, z = 0.70, e = 0.75, gens = 100
Final resource density = 	9.822985824327981
Final consumer density = 	5.396573884603115

**********************************************************************

Code ran without errors

Time consumed = 0.76040s

======================================================================
Inspecting script file fmr.R...

File contents are:
**********************************************************************

# Plots log(field metabolic rate) against log(body mass) for the Nagy et al 
# 1999 dataset to a file fmr.pdf.
rm(list=ls())
cat("Reading CSV\n")
nagy <- read.csv('../Data/NagyEtAl1999.csv', stringsAsFactors = FALSE)

cat("Creating graph\n")
pdf('../Results/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class], 
     xlab=~log[10](M), ylab=~log[10](FMR))
for(class in unique(nagy$Class)){
    model <- lm(log10(FMR.kJ.day.1) ~ log10(M.g), data=nagy[nagy$Class==class,])
    abline(model, col=col[class])
}
dev.off()

cat("Finished in R!\n")
**********************************************************************

Testing fmr.R...

Output (only first 500 characters): 

**********************************************************************
Reading CSV
Creating graph
null device 
          1 
Finished in R!

**********************************************************************

Code ran without errors

Time consumed = 0.18079s

======================================================================
Inspecting script file using_os.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" OS walk exercises. Produces lists of files and directories in home directory up to specified recursion depth (default 1)"""

__appname__ = 'profileme_np.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import os
from os.path import expanduser
import subprocess

home = subprocess.os.path.expanduser("~")

# Use the subprocess.os module to get a list of files and  directories 
# in your ubuntu home directory 
# 



def flatten(l):
    """
    Recursive function to flatten a list of lists, to single list contiaing elements of passed list.

    PARAMETERS
    ----------
    l : list
        list to flatten

    RETURNS
    -------
    list
        list of elements in passed l
    """
    flatter = []
    flat = True
    for item in l:
        if type(item) == list:
            flat = False
            for subitem in item:
                flatter.append(subitem)
        else:
            flatter.append(item)
    if flat:
        return flatter
    return flatten(flatter)

def get_files_and_dirs(root, recursion_depth, bool_print):
    """
    Get list of files and directories in specified root directory, up to a specified recursion depth.

    PARAMETERS
    ----------
    root : string
        directory to find contents of
    recursion depth : int
        depth to search for files and directories -  (maximum distance from root)
    p : bool
        whether to print directories and contents to console
    """

    filesL = []
    dirsL = []
    for curr_dir, dirs, fs in os.walk(root):

        if bool_print:
            print("files in {}:".format(curr_dir))
            for f in fs:
                print("\t{}".format(f))
            print('\n')

            print("dirs in {}:".format(curr_dir))
            for d in dirs:
                print("\t{}".format(d))
            print('\n')

        filesL.append(fs.copy())
        dirsL.append(dirs.copy())
        if curr_dir.count(os.sep) - root.count(os.sep) == recursion_depth:
                del dirs[:]

    return flatten(filesL), flatten(dirsL)


# fs, ds = list of files, list of directories - in home directory with recursion depth 0 
fs,ds = get_files_and_dirs(home,0,True)

# Hint: look in subprocess.os and/or subprocess.os.path and/or 
# subprocess.os.walk for helpful functions


#################################
#~Get a list of files and 
#~directories in your home/ that start with an uppercase 'C'

# Create a list to store the results.
FilesDirsStartingWithC = []

# Use a for loop to walk through the home directory - recursion depth 1
# fs, ds = list of files, list of directories - in home directory with recursion depth 0 
fs,ds = get_files_and_dirs(home,1,False)

# list comprehension to produce lists of files and directories starting with "C"
FilesDirsStartingWithC = [[f for f in fs if f[0] == "C"], [d for d in ds if d[0] == "C"]]

# Print out results in nice format
print("Files/Dirs starting with C:")
print("\tFiles:")
discard = [print("\t\t"+f) for f in FilesDirsStartingWithC[0]]
print("\tDirs:")
discard = [print("\t\t"+f) for f in FilesDirsStartingWithC[1]]
print("\n")


#################################
# Get files and directories in your home/ that start with either an 
# upper or lower case 'C'

# list comprehension to produce lists of files and directories starting with "C" or "c"
FilesDirsStartingWithCorc = [[f for f in fs if (f[0] == "C" or f[0] == "c")], [d for d in ds if (d[0] == "C" or d[0] == "c")]]

# print out with nice format
print("Files/Dirs starting with C/c:")
print("\tFiles:")
discard = [print("\t\t"+f) for f in FilesDirsStartingWithCorc[0]]
print("\tDirs:")
discard = [print("\t\t"+f) for f in FilesDirsStartingWithCorc[1]]
print("\n")

#################################
# Get only directories in your home/ that start with either an upper or 
#~lower case 'C' 

# list comprehension to produce list of directories starting with "C" or "c"
DirsStartingWithCorc = [d for d in ds if (d[0] == "C" or d[0] == "c")]
# print out with nice format
print("Dirs:")
discard = [print("\t"+f) for f in DirsStartingWithCorc]**********************************************************************

Testing using_os.py...

using_os.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
files in /home/mhasoba:
	.gitconfig
	.bash_logout
	logpath
	.profile
	.python_history
	.sqlite_history
	.bashrc
	.gtk-bookmarks
	.ICEauthority
	.desktop_items.txt
	.sudo_as_admin_successful
	.bash_history
	.wget-hsts
	.Rhistory
	.RData
	.lesshst


dirs in /home/mhasoba:
	.dbus
	.remmina
	.zoom
	Music
	.VirtualBox
	.ssh
	.mume
	.jupyter
	.vscode
	.nano
	.mozilla
	.ipynb_checkpoints
	.fontconfig
	.dropbox
	.unison
	.Skype
	.gnome
	.pylint.d
	.QtWebEngineProcess
	.julia
	.aspnet
	.sage
	.gphoto
	Des
**********************************************************************

Code ran without errors

Time consumed = 0.03755s

======================================================================
Inspecting script file LV1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Program to solve Lotka-Volterra model with hard-coded paramterter values, by numerical integration. Outputs final population sizes and saves 'population size vs time' and 'consumer popn size vs
resource popn size' graphs to pdf.

INPUTS:
    None

OUTPUTS:
    ../Results/LV1_C_vs_R.pdf   =   Counsumer and Resource popn sizes vs time
    ../Results/LV1_time.pdf     =   Consumer vs Resource population size plot
"""

__appname__ = 'LV1.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports
import scipy.integrate as integrate
import scipy as sc
import sys
import matplotlib.pylab as p



def dCR_dt(pops, t=0):
    """
    Calculate dR/dT and dC/dT ( = change in resource and consmer population sizes) given current popuation sizes
    for Lotka- Volterra model.

    PARAMETERS
    ----------
    pops : array, list
        list of length 2; first element is Resource population size, second element is Consumer population size
    t : float,int
        time

    RETURNS
    -------
    array
        array containing dR/dT and dC/dT
    """
    R = pops[0]
    C = pops[1]
    dRdt = r * R - a * R * C 
    dCdt = -z * C + e * a * R * C
    
    return sc.array([dRdt, dCdt])

def run_sim(RC0, t):
    """
    Solve Lotka-Volterra Model by numerical integraton, for a given initial population sizes
    
    PARAMETERS
    ----------
    RC0 : array, list
        inital Resource and Consumer population sizes
    t : array
        time values at which to perform numerical integration

    RETURNS
    -------
    pops : array
        array of Consumer and Resource population sizes at each timestep in argument t
    infodict : dict
        dictionary containing information about the integration
     """
    pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)
    return pops, infodict

def make_plots(pops):
    """
    Make and save plots of population size vs time, and Consumer population size vs Resource population size

    PARAMETERS
    ----------
    pops : array
        array of population sizes at each timestep

    RETURNS
    -------
    None

    """
    f1 = p.figure()
    p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
    p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
    p.grid()
    p.legend(loc='best')
    p.xlabel('Time')
    p.ylabel('Population density')
    p.title('Consumer-Resource population dynamics - Basic Lotka Volterra Model')

    f1.savefig('../Results/LV1_time.pdf') #Save figure 


    f2 = p.figure()

    p.plot(pops[:,0], pops[:,1]  , 'r-')
    p.grid()
    p.xlabel('Resource density')
    p.ylabel('Consumer density')
    p.title('Consumer-Resource population dynamics - Basic Lotka Volterra Model')

    f2.savefig('../Results/LV1_C_vs_R.pdf') #Save figure 

    print("Final resource density = \t{}\nFinal consumer density = \t{}".format(pops[-1][0],pops[-1][1]))

    return None

def main():
    """ Main entry point for program; set global variables to specify and evaluate LV model. """
    # set params

    global r,a,z,e
    r,a,z,e = 1., 0.1, 0.80, 0.75


    global t
    t = sc.linspace(0, 15, 1000)

    global R0, C0
    R0, C0 = 10, 5
    global RC0

    RC0 = sc.array([R0, C0])

    pops, infodict = run_sim(RC0, t)
    make_plots(pops)

    return 0

if __name__ == '__main__':
    status = main()
    sys.exit(status)**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Final resource density = 	12.411143769903134
Final consumer density = 	5.081597476283375

**********************************************************************

Code ran without errors

Time consumed = 0.80831s

======================================================================
Inspecting script file DrawFW.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Script drawing randomly generated food web. Node size represents body size, edge represents feeding interaction.


INPUTS:
    None

OUTPUTS:
    ../Results/FoodWeb.pdf   =   Random food web network

"""

__appname__ = 'DrawFW.py'
__author__  = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import networkx as nx
import scipy as sc
import matplotlib.pyplot as p

def GenRdmAdjList(N = 2, C = 0.5):
    """
    Generate a random adjacency list.

    PARAMETERS
    ----------
    N : int
        number of nodes
    C : float
        connectivity - the probability that two wandomly selected nodes are conneted by an edge

    RETURNS
    -------
    list
        List of adjacent nodes

    """

    Ids = range(N)
    ALst = []
    for i in Ids:
        if sc.random.uniform(0,1,1) < C:
            Lnk = sc.random.choice(Ids,2).tolist()
            if Lnk[0] != Lnk[1]: #avoid self (e.g., cannibalistic) loops
                ALst.append(Lnk)
    return ALst

MaxN = 30
C = 0.75

# array of lists adjacency list
AdjL = sc.array(GenRdmAdjList(MaxN, C))

# species IDs
Sps = sc.unique(AdjL) # get species ids

# array of sizes
SizRan = ([-10,10]) #use log10 scale
Sizs = sc.random.uniform(SizRan[0],SizRan[1],MaxN)
p.hist(Sizs) #log10 scale
p.hist(10 ** Sizs) #raw scale
NodSizs= 1000 * (Sizs-min(Sizs))/(max(Sizs)-min(Sizs))
p.close('all') # close all open plot objects
f1 = p.figure()

# automatically generate coords
pos = nx.circular_layout(Sps)

# draw graph
G = nx.Graph()
G.add_nodes_from(Sps)
G.add_edges_from(tuple(AdjL))
nx.draw_networkx(G, pos, node_size = NodSizs)


# save graph
print("Saving food web to ../Results/FoodWeb.pdf")
p.savefig("../Results/FoodWeb.pdf")**********************************************************************

Testing DrawFW.py...

DrawFW.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Saving food web to ../Results/FoodWeb.pdf

**********************************************************************

Encountered error (or warning):
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:522: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(edge_color) \
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:543: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if cb.is_string_like(edge_color) or len(edge_color) == 1:
/usr/lib/python3/dist-packages/networkx/drawing/nx_pylab.py:724: MatplotlibDeprecationWarning: The is_string_like function was deprecated in version 2.1.
  if not cb.is_string_like(label):

======================================================================
Inspecting script file Nets.R...

File contents are:
**********************************************************************
library(igraph) # Load the igraph package

rm(list = ls())

# 	ICL	UoR	CEH	ZSL	CEFAS	Nonacademic/CASE
# ICL	0	0	10	9	5	70
# UoR		0	12	0	2	76
# CEH			0	0	0	6
# ZSL			       0 	0	28
# CEFAS			       0	0
# Nonacademic/CASE                        0

links <- read.csv("../data/QMEE_Net_Mat_edges.csv", header=T, as.is=T)
nodes <- read.csv("../data/QMEE_Net_Mat_nodes.csv", header=T, row.names = 1)

#Create graph object
net <- graph.adjacency(as.matrix(links), mode = "directed", weighted=TRUE, diag=F)
        
#Test plot
# plot(net, edge.arrow.size=1, edge.curved=.1,
#      vertex.color="orange", vertex.frame.color="#555555",
#      vertex.label=V(net)$Type, vertex.label.color="black",
#      vertex.label.cex=.7) 

# Generate colors based on partner type:
colrs <- c("green", "red", "blue")
V(net)$color <- colrs[nodes$Type]

# Set node size based on Number of PIs:
# V(net)$size <- V(net)$Pis*0.9

V(net)$size <- 50

# Set edge width based on weight (PhD Students):
E(net)$width <- E(net)$weight

#change arrow size and edge color:
E(net)$arrow.size <- 1
E(net)$edge.color <- "gray80"

E(net)$width <- 1+E(net)$weight/10

graphics.off()

svg("../results/QMEENet.svg",width=7,height=7)

plot(net, edge.curved=0, vertex.label.color="black") 

legend(x=-1.5, y=-0.1, c("Hosting Partner", "Non-hosting Partner", "University"), pch=21,
       col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)

dev.off()**********************************************************************

Testing Nets.R...

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Loading required package: methods

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

Error in file(file, "rt") : cannot open the connection
Calls: read.csv -> read.table -> file
In addition: Warning message:
In file(file, "rt") :
  cannot open file '../data/QMEE_Net_Mat_edges.csv': No such file or directory
Execution halted

======================================================================
Inspecting script file run_fmr_R.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Script calling fmr.R to produce plot """

__appname__ = 'run_fmr.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import subprocess


# open subprocess
p = subprocess.Popen(["Rscript", "fmr.R"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
stdout, stderr = p.communicate()

# check whether stderr is empty
if stderr != b'':
    # print error message to console if not empty
    print("error message produced:")
    print(stderr.decode())
else:
    print("\nRun successful!\n\nR output:\n---------")

# print stdout to console
print(stdout.decode())**********************************************************************

Testing run_fmr_R.py...

run_fmr_R.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************

Run successful!

R output:
---------
Reading CSV
Creating graph
null device 
          1 
Finished in R!


**********************************************************************

Code ran without errors

Time consumed = 0.17392s

======================================================================
Inspecting script file run_LV.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Run and profile 4 Lotka Volterra programs. Prints the top 20 calls by tottime to terminal"""


__appname__ = 'LV_run.py'
__author__  = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports
import LV1
import LV2
import LV3
import LV4
import cProfile
import pstats


# LV1 : Simple LV

prof = cProfile.Profile()

prof.enable()
LV1.main()
prof.disable()

print("\nLV1 profile - top 20 by tottime:\n--------------------------------")
ps = pstats.Stats(prof)
ps.sort_stats("tottime").print_stats(20)

# LV2 : add resource density dependant growth

prof = cProfile.Profile()

prof.enable()
LV2.main([])
prof.disable()

print("\nLV2 profile - top 20 by tottime:\n--------------------------------")
ps = pstats.Stats(prof)
ps.sort_stats("tottime").print_stats(20)

# LV3 : discrete time LV model

prof = cProfile.Profile()

prof.enable()
LV3.main([])
prof.disable()

print("\nLV3 profile - top 20 by tottime:\n--------------------------------")
ps = pstats.Stats(prof)
ps.sort_stats("tottime").print_stats(20)

# LV4 discrete time with random Gaussian fluctuations each timestep

prof = cProfile.Profile()

prof.enable()
LV4.main([])
prof.disable()

print("\nLV4 profile - top 20 by tottime:\n--------------------------------")
ps = pstats.Stats(prof)
ps.sort_stats("tottime").print_stats(20)






**********************************************************************

Testing run_LV.py...

run_LV.py is a Python script file;

checking for docstrings...

Found no functions, but one docstring for the script, good

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Final resource density = 	12.411143769903134
Final consumer density = 	5.081597476283375

LV1 profile - top 20 by tottime:
--------------------------------
         269804 function calls (265048 primitive calls) in 0.451 seconds

   Ordered by: internal time
   List reduced from 1404 to 20 due to restriction <20>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        2    0.120    0.060    0.120    0.060 {built-in method _tkinter.create}
      148    0.029    0.000    0.
**********************************************************************

Code ran without errors

Time consumed = 1.95831s

======================================================================
Inspecting script file LV2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""
Program to solve Lotka-Volterra model with prey density dependence by numerical integration. Parameter valeus for r,a,z,e are passed from command line, with K = 20, R0 = 10, C0 = 5 set. If no arguments are passed from command line, default values which give stable population sizes
are used. Outputs final population sizes and saves 'population size vs time' and 'consumer popn size vs resource popn size graphs to pdf.

INPUTS:
    r   =   intrinsic growth rate
    a   =   per capita search rate * attack success probability
    z   =   mortality rate
    e   =   consumer effciency

OUTPUTS:
    ../Results/LV2_C_vs_R.pdf   =   Counsumer and Resource popn sizes vs time
    ../Results/LV2_time.pdf     =   Consumer vs Resource population size plot

"""

__appname__ = 'LV2.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

# imports

import scipy as sc
import scipy.integrate as integrate
import sys

import scipy.integrate as integrate
import scipy as sc
import sys
import matplotlib.pylab as p



def dCR_dt(pops, t=0):
    """
    Calculate dR/dT and dC/dT ( = change in resource and consmer population sizes) given current popuation sizes
    for Lotka- Volterra model with prey density dependent growth.

    PARAMETERS
    ----------
    pops : array, list
        list of length 2; first element is Resource population size, second element is Consumer population size
    t : float,int
        time

    RETURNS
    -------
    array
        array containing dR/dT and dC/dT
    """
    R = pops[0]
    C = pops[1]
    dRdt = r * R * (1 - R / K) - a * R * C 
    dCdt = -z * C + e * a * R * C
    
    return sc.array([dRdt, dCdt])

def run_sim(RC0, t):
    """
    Solve Lotka-Volterra Model by numerical integraton, for a given initial population sizes
    
    PARAMETERS
    ----------
    RC0 : array, list
        inital Resource and Consumer population sizes
    t : array
        time values at which to perform numerical integration

    RETURNS
    -------
    pops : array
        array of Consumer and Resource population sizes at each timestep in argument t
    infodict : dict
        dictionary containing information about the integration
    """
    pops, infodict = integrate.odeint(dCR_dt, RC0, t, full_output=True)
    return pops, infodict
# plotting

def make_plots(pops):
    """
    Make and save plots of population size vs time, and Consumer population size vs Resource population size

    PARAMETERS
    ----------
    pops : array
        array of population sizes at each timestep

    RETURNS
    -------
    None

    """
    f1 = p.figure()
    p.plot(t, pops[:,0], 'g-', label='Resource density') # Plot
    p.plot(t, pops[:,1]  , 'b-', label='Consumer density')
    p.grid()
    p.legend(loc='best')
    # vairable position required for text:
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e),  x = 12.5, y = max(pops.ravel())*0.85,  bbox=dict(facecolor='white', edgecolor='black',alpha=0.5))

    p.xlabel('Time')
    p.ylabel('Population density')
    p.title('C-R population dynamics - LV with prey density dependence')
    f1.savefig('../Results/LV2_model_vs_t.pdf') #Save figure 


    f2 = p.figure()
    p.plot(pops[:,0], pops[:,1]  , 'r-')
    p.grid()
    # variable position text box
    p.text(s = "r = {}\na = {}\nz = {}\ne = {}".format(r,a,z,e), x = max(pops[:,0])-(max(pops[:,0])-min(pops[:,0]))*0.2, y = max(pops[:,1])-(max(pops[:,1])-min(pops[:,1]))*0.2,  bbox=dict(facecolor='white', edgecolor='black'))

    p.xlabel('Resource density')
    p.ylabel('Consumer density')
    p.title('C-R population dynamics - LV with prey density dependence')
    f2.savefig('../Results/LV2_model_C_vs_R.pdf') #Save figure 


    print("Final resource density = \t{}\nFinal consumer density = \t{}".format(pops[-1][0],pops[-1][1]))
    return



def check_args(args):
    """
    Check if arguments passed from command line are 4 numeric values
    PARAMETERS
    ----------
    args : list
        list of command line parameters


    RETURNS
    -------
    list or 1
        list of float parameter values if no error occurred; otherwise 1
    """
    if len(args) == 0:
        print("Using default parameter values giving stable population sizes: r = 1.0, a = 0.1, z = 0.70, e = 0.75 ")
        return [1.0, 0.1, 0.70, 0.75]


    if len(args) != 4:
        print("Please provide 4 parameter values: r, a, z, e")
        return 1


    try:
        numeric_list = list(map(float, args))
        return numeric_list
    except:
        print("Please provide 4 numeric arguments: r, a, z, e.")
        return 1

    return


def main(args):
    """
    Main entry point for program
    PARAMATERS
    ----------
    args : list
        list of parameters passed from command line, containing r, a, z, e LV parameter values.
        
    RETURNS
    -------
    0 or 1
        0 if no erros encountered; otherwise 1
    """
    # set params


    numeric_args = check_args(args)

    if numeric_args == 1:
        return 1
    
    global r,a,z,e
    r,a,z,e = numeric_args

    global t
    t = sc.linspace(0, 15, 1000)


    global K, R0, C0
    K, R0, C0 = 20, 10, 5

    global RC0
    RC0 = sc.array([R0, C0])

    pops, infodict = run_sim(RC0, t)
    make_plots(pops)

    return 0

if __name__ == '__main__':
    status = main(sys.argv[1:])
    sys.exit(status)









**********************************************************************

Testing LV2.py...

LV2.py is a Python script file;

checking for docstrings...

Found one or more docstrings and functions

Current Points = 100

Output (only first 500 characters): 

**********************************************************************
Using default parameter values giving stable population sizes: r = 1.0, a = 0.1, z = 0.70, e = 0.75 
Final resource density = 	9.328843951796904
Final consumer density = 	5.346882371277303

**********************************************************************

Code ran without errors

Time consumed = 0.79446s

======================================================================
======================================================================
Finished running scripts

Ran into 3 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 100

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!