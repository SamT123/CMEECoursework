Starting weekly assessment for Sam, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 2.38 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git, Week3

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*.tmp
*.DS_store
*.pyc
__pycache__**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# **2019-20 CMEE Coursework Repository**
## Author
Sam Turner
## Contents
### [Week 1](https://github.com/SamT123/CMEECoursework/tree/master/Week1)
* UNIX
* Shell scripting
* LaTex

### [Week 2](https://github.com/SamT123/CMEECoursework/tree/master/Week2)
* Python

## Prerequisites
### Python 3.x
`pickle`	`stringdist`
 

**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README.md

Checking for readme file in weekly directory...

Found README in parent directory, named: README.md

Printing contents of README.md:
**********************************************************************
# Week 2
Coursework for CMEE week 2.
## Topics:
* Python

## Contents
### [Code](https://github.com/SamT123/CMEECoursework/tree/master/Week2/Code)
* basic_io1.py
	* Demonstrate reading and writing of text files
* basic_io2.py
	* Demonstrate reading and writing of text files
* basic_io3.py
	* Demonstrate reading and writing of text files
* basic_csv.py
	* Demonstrate reading and writing of csv files
* cfexercises1.py
	* Demonstrate conditional statements, iteration and recursion as methods of control flow
	* This script has been converted into a program in a Practical exercise.
* cfexercises2.py
	* Demonstrate iteration
* loops.py
	* Demonstrate iteration and conditional statements
* oaks.py
	* Demonstrate list comprehensions
* scope.py
	* Demonstrate variable scope and local environments
* boilerplate.py
	* Demonstrate how a python program is composed
* using_name.py
	* Demonstrate how control flow can be used to alter program behaviour based on how the module is called
* sysargv.py
	* Demonstrate how command line arguemnts can be accessed in a python script
* control_flow.py
	* A collection of functions in a python program to demonstrate program/script differences
* lc1.py
	* List comprehension exercises on bird weight data
* lc2.py
	* List comprehension exercises on rainfall data
* tuple.py
	* List comprehension exercises on bird weight data
* dictionary.py
	* Dictionary comperehesnion exercise on taxonomic data
* test_control_flow.py
	* Demonstrate doctests
* debugme.py
	* Script with divide by zero error to demonstrate debugging methods
* align_seqs.py
	* Finds best alignment (without indels) between two sequences provided in ../Data/sequences.csv
	* Best alignment is saved to ../Results/best_align.txt
	* Example usage:
	`python3 align_seqs_better.py`
* align_seqs_fasta.py
	* Finds best alignment (without indels) between sequences provided as command line arguments
	* If no arguments are passed, defaults are used
	* Best alignment is saved to ../Results/best_align_fasta.txt
	* Example usage:
	`python3 align_seqs_fasta.py ../Data/fasta/407228326.fasta ../Data/fasta/407228412.fasta`
* align_seqs_better.py
	* Finds best alignment (without indels) between two sequences provided in ../Data/sequences.csv
	* If multiple best alignments are present, these are all provided
	* Best alignments are saved to ../Results/best_align_better.txt
	* Example usage:
	`python3 align_seqs_better.py`
* oaks_debugme.py
	* Program which determines whether a species falls within the oak genus, Quercus.





## [Data](https://github.com/SamT123/CMEECoursework/tree/master/Week2/Data)
* testcsv.csv
	* csv file with bird species information
* fasta
	* fasta files for alignment by align_seqs_fasta.py
* TestOaksData.csv
	* species names to categorise
* bodymass.csv
	* bird bodymass and species name information
* sequences.csv
	* DNA sequences to align
## [Results](https://github.com/SamT123/CMEECoursework/tree/master/Week2/Results)
**********************************************************************

Found following files in results directory: JustOaksData.csv, bodymass.csv, best_align.txt, best_align_fasta.txt, README.md, best_align_better.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 23 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, basic_io3.py, cfexercises1.py, tuple.py, lc1.py, oaks_debugme.py, oaks.py, loops.py, using_name.py, align_seqs.py, basic_io2.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py, basic_io1.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.

greater_hundred_month_fall_lc = [month_fall for month_fall in rainfall if month_fall[1] > 100.0]
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

less_fifty_month_lc = [month_fall[0] for month_fall in rainfall if month_fall[1] < 50.0]

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

greater_hundred_month_fall_loop = []

for month_fall in rainfall:
    if month_fall[1] > 100:
        greater_hundred_month_fall_loop.append(month_fall)

less_fifty_month_loop = []

for month_fall in rainfall:
    if month_fall[1] < 50:
        less_fifty_month_loop.append(month_fall[0])**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 99

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.04273s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A boilerplate demonstrating the structure of a Python program"""

__appname__ = 'boilerplate.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

## imports

import sys

## constants

## functions

def main(argv):
    """main entry point for program"""
    print('This is a boilerplate')
    return 0

if __name__ == '__main__':
    """ensures the main funtion is called when program is run from command line"""
    status = main(sys.argv)
    sys.exit(status)
    **********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.03409s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
############
# FILE INPUT
############
# Open a  file for reading

import csv

f = open('../Data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []

for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is", row[0])

f.close()


# write a file containing only speices name and Body mass

f = open('../Data/testcsv.csv','r')
g = open('../Results/bodymass.csv', 'w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0], row[4]])

f.close()
g.close()
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 98

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.03127s

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
for j in range(12):
    if j % 3 == 0:
        print('hello')

for j in range(15):
     if j % 5 == 3:
        print('hello')
     elif j % 4 == 3:
        print('hello')

z = 0
while z != 15:
    print('hello')
    z = z + 3

z = 12
while z < 100:
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 97

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.02840s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************

"""
Sequence aligner. Finds best sequence alignment(s) (without indels) between two sequences provided
in ../Data/sequences_better.csv

Results are written to ../Results/best_align_better.csv.
"""

__appname__ = 'align_seqs_better.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

import csv
import sys

# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    Calculate the alignment score for a pair of sequences and a startpoint for the shorter sequence.
    
    Parameters
    ----------
    s1 : str
        the longer of the two sequences to align

    s2 : str
        the shorter of the two sequences to align

    l1 : int
        the length of the longer sequence

    l2 : int
        the length of the shorter sequence

    startpoint : int
        the position at which the shorter sequence should be placed
        for this alignment calculation

    Returns
    -------
    score : int
        number of matching base positions for this alignment

    matched : str
        per base alignment



    >>> calculate_score('ATCGATCG','TCGATCG',8,7,0)
    0, '-------'

    >>> calculate_score('ATCGTCG','TCGATCG',7,7,1)
    3, '***---'
    """

    matched = "" # to hold string displaying alignements
    score = 0


    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score, matched



def main(argv):
    """ Main entry point for program when called from terminal """

    # read sequences from ../Data/sequences.csv

    f = open('../Data/sequences_better.csv','r')

    csvread = csv.reader(f)
    sequences = []

    for row in csvread:
        sequences.append(row[0])

    seq1, seq2 = sequences[0],sequences[1]

    # Assign the longer sequence s1, and the shorter to s2
    # l1 is length of the longest, l2 that of the shortest

    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths


    # now try to find the best match (highest score) for the two sequences

    # keep lists of best alignments, appending equally good alignments.
    my_best_align = []
    my_best_match = []
    my_best_score = -1

    for i in range(l1):
        z,match = calculate_score(s1, s2, l1, l2, i)
        if z == my_best_score:
            my_best_align.append("." * i + s2)
            my_best_match.append("." * i + match)
        if z > my_best_score:
            my_best_align = ["." * i + s2] # think about what this is doing!
            my_best_match = ["." * i + match]
            my_best_score = z


    # write results to file

    g = open('../Results/best_align_better.txt', 'w')

    # produce list of lines in the file
    lines = ["Best score: {} achieved {} times.".format(my_best_score,len(my_best_match))]

    for i in range(len(my_best_match)):
        lines.append('')
        lines.append(str(i))
        lines.append(my_best_match[i])
        lines.append(my_best_align[i])
        lines.append(s1)
    
    g.write("\n".join(lines))

    print("Best score: {} achieved {} times.".format(my_best_score,len(my_best_match)))

    for i in range(len(my_best_match)):
        print(my_best_match[i])
        print(my_best_align[i])
        print(s1)
        print('\n')
    

    return 0

if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)


**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
*******
ATATATA
ATATATATATA
7
 
.-------
.ATATATA
ATATATATATA
0
 
..*******
..ATATATA
ATATATATATA
7
 
...-------
...ATATATA
ATATATATATA
0
 
....*******
....ATATATA
ATATATATATA
7
 
.....------
.....ATATATA
ATATATATATA
0
 
......*****
......ATATATA
ATATATATATA
5
 
.......----
.......ATATATA
ATATATATATA
0
 
........***
........ATATATA
ATATATATATA
3
 
.........--
.........ATATATA
ATATATATATA
0
 
..........*
..........ATATATA
ATATATATATA
1
 
Best score: 7 achieved 3 times.
*******
ATATATA
ATATATATATA

**********************************************************************

Code ran without errors

Time consumed = 0.02918s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
taxa = [
         ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]

# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 


# produce a dictionary {order1: set(), order2: set()... }
print('finding orders...\n')
taxa_dic = {order_taxon_pair[1]: set() for order_taxon_pair in taxa}

# populate dictionary by looping over tuples in taxa list
print('adding taxa...\n')
for taxon,order in taxa:
        taxa_dic[order].add(taxon)

# print dictionary
for order in taxa_dic.keys():
        print('Order:\t', order)
        s=''.join((ind + ', ') for ind in taxa_dic[order])
        print('Taxa:\t', s[:-2])
        print('\n')
**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 96

Output (only first 500 characters): 

**********************************************************************
finding orders...

adding taxa...

Order:	 Afrosoricida
Taxa:	 Microgale dobsoni, Microgale talazaci


Order:	 Carnivora
Taxa:	 Arctocephalus gazella, Canis lupus, Lyacon pictus


Order:	 Rodentia
Taxa:	 Gerbillus henleyi, Mus domesticus, Cleithrionomys rutilus, Peromyscus crinitus


Order:	 Chiroptera
Taxa:	 Myotis lucifugus



**********************************************************************

Code ran without errors

Time consumed = 0.02862s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
import ipdb; ipdb.set_trace()

def createabug(x):
    """function with divide by zero error"""
    y = x**4

    z = 0
    
    y = y/z
    return y

createabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
]0;IPython: Week2/Code> [0;32m/home/mhasoba/Documents/Teaching/IC_CMEE/2019-20/Coursework/StudentRepos/SamTurner_SAT19/Week2/Code/debugme.py[0m(3)[0;36m<module>[0;34m()[0m
[0;32m      1 [0;31m[0;32mimport[0m [0mipdb[0m[0;34m;[0m [0mipdb[0m[0;34m.[0m[0mset_trace[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
[0m[0;32m      2 [0;31m[0;34m[0m[0m
[0m[0;32m----> 3 [0;31m[0;32mdef[0m [0mcreateabug[0m[0;34m([0m[0mx[0m[0;34m)[0m[0;34m:[0m[0;34m[0m[0m
[0m[0;32m   
**********************************************************************

Code ran without errors

Time consumed = 0.66352s

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
## Try this first

_a_global = 10

if _a_global >= 5:
    _b_global = _a_global +5

def a_function():
    """a function demonstrating variable scope"""
    _a_global = 5

    if _a_global >= 5:
        _b_global = _a_global +5

    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value of _b_global is ", _b_global)
    print("Inside the function, the value of _a_local is ", _a_local)
    return None

a_function()

print("Outside the function, the value of _a_global is ", _a_global)
print("Outside the function, the value of _b_global is ", _b_global)




print('\n\n\n')

del(_a_global)
del(_b_global)
## Now try this

_a_global = 10

def a_function():
    """a function demonstrating variable scope"""
    _a_local = 4
    print("Inside the function, the value of _a_local is ", _a_local)
    print("Inside the function, the value of _a_global is ", _a_global)
    return None

a_function()
print("Outside the function, the value of _a_global is", _a_global)

print('\n\n\n')

del(_a_global)

# Global keyword 

_a_global = 10

print("Outside the function, the value of _a_global is", _a_global)

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4
    
    print("Inside the function, the value of _a_global is ", _a_global)
    print("Inside the function, the value _a_local is ", _a_local)
    
    return None

a_function()

print("Outside the function, the value of _a_global now is", _a_global)


print('\n\n\n')

del(_a_global)

# Nested functions and global keywords

def a_function():
    _a_global = 10

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is ", _a_global)

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)


print('\n\n\n')

del(_a_global)


# Nested functions and global keywords


_a_global = 10

def a_function():

    def _a_function2():
        global _a_global
        _a_global = 20
    
    print("Before calling a_function2, value of _a_global is ", _a_global)

    _a_function2()
    
    print("After calling _a_function2, value of _a_global is ", _a_global)

a_function()

print("The value of a_global in main workspace / namespace is ", _a_global)**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Missing docstrings in one more functions!
.5 pt deducted per missing docstring

Current Points = 88.0

Output (only first 500 characters): 

**********************************************************************
Inside the function, the value of _a_global is  5
Inside the function, the value of _b_global is  10
Inside the function, the value of _a_local is  4
Outside the function, the value of _a_global is  10
Outside the function, the value of _b_global is  15




Inside the function, the value of _a_local is  4
Inside the function, the value of _a_global is  10
Outside the function, the value of _a_global is 10




Outside the function, the value of _a_global is 10
Inside the function, the value of _a_
**********************************************************************

Code ran without errors

Time consumed = 0.03220s

======================================================================
Inspecting script file basic_io3.py...

File contents are:
**********************************************************************
#############################
# STORING OBJECTS
#############################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()

## Load the data again
f = open('../sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io3.py...

basic_io3.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 87.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io3.py", line 9, in <module>
    f = open('../sandbox/testp.p','wb') ## note the b: accept binary files
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testp.p'

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""A collection of trivial mathematical operations in unhelpfully named functions"""

__appname__ = 'cfexercises1_program.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

import sys

# What does each of foo_x do? 
def foo_1(x=25):
    """ compute square root of x
    PARAMETERS
    ----------
    x : int, float
        number whose root we require

    """
    
    return '{:.4f} is the square root of {}'.format(x ** 0.5, x)

def foo_2(x=5, y=10):
    """return the largest of x, y
    
    PARAMETERS
    ----------
    x : int, float
    y : int, float

    """
    if x > y:
        return '{} is the larger of {} and {}'.format(x,x,y)
    return '{} is the larger of {} and {}'.format(y,x,y)

def foo_3(x=3, y=2, z=1):
    """return x, y, z, partially sorted into descending order: 
    if x>y, switch x and y; then, if y>z, switch y and z
    
    PARAMETERS
    ----------
    x : int, float
    y : int, float
    z : int, float   
    """


    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return 'the paritally sorted list is {}, {}, {}'.format(x,y,z)

def foo_4(x=5):
    """calculate factorial of x iteratively
    PARAMETERS
    ----------
    x : int, float
    """
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return '{} is {} factorial'.format(result,x)

def foo_5(x=5): # a recursive function that calculates the factorial of x
    '''calculate factorial of x recursively
    PARAMETERS
    ----------
    x : int, float'''
    if x == 1:
        return 1
    return x * foo_5(x - 1)

def foo_6(x=5): # Calculate the factorial of x in a different way
    '''calculate factorial of x iteratively
    PARAMETERS
    ----------
    x : int, float'''
    x2 = x
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x - 1
    return '{} is {} factorial'.format(facto,x2)


def main(argv):
    '''main entry point for program'''
    print(foo_1(10))
    print(foo_2())
    print(foo_3())
    print(foo_4())
    print(foo_5())
    print(foo_6())

    return 0

if __name__ == '__main__':
    '''makes sure the main funtion is called from command line'''
    status = main(sys.argv)
    sys.exit(status)


    **********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
3.1623 is the square root of 10
10 is the larger of 5 and 10
the paritally sorted list is 2, 1, 3
120 is 5 factorial
120
120 is 5 factorial

**********************************************************************

Code ran without errors

Time consumed = 0.03474s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line or output block by species 
# Hints: use the "print" command! You can use list comprehensions!


# discard variable catches the NoneType list which the comprehension evaluates to, as print(arg) evaluates to NoneType.
discard = [print('Latin:\t%s\nCommon:\t%s\nWeight:\t%s\n' % bird_info) for bird_info in birds]
**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 86.0

Output (only first 500 characters): 

**********************************************************************
Latin:	Passerculus sandwichensis
Common:	Savannah sparrow
Weight:	18.7

Latin:	Delichon urbica
Common:	House martin
Weight:	19

Latin:	Junco phaeonotus
Common:	Yellow-eyed junco
Weight:	19.5

Latin:	Junco hyemalis
Common:	Dark-eyed junco
Weight:	19.6

Latin:	Tachycineata bicolor
Common:	Tree swallow
Weight:	20.2


**********************************************************************

Code ran without errors

Time consumed = 0.05249s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 


latin_names_lc = [bird_info[0] for bird_info in birds]
common_names_lc = [bird_info[1] for bird_info in birds]
weights_lc = [bird_info[2] for bird_info in birds]

# (2) Now do the same using conventional loops (you can choose to do this 
# before 1 !). 

latin_names_loop = []

for bird_info in birds:
    latin_names_loop.append(bird_info[0])


common_names_loop = []

for bird_info in birds:
    common_names_loop.append(bird_info[1])

weights_loop = []

for bird_info in birds:
    weights_loop.append(bird_info[2])
**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 85.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.06032s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
"""
Program which determines whether a species falls within the oak genus, Quercus.
"""

__appname__ = 'oaks_debugme.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 
import csv
import sys
# import stringdist

# typo detection using stringdist algorithm commented out to remove dependency requirement

print("*** INSTALL AND IMPORT stringdist FOR TYPO DETECTION ***\n\n")

# Define function
def is_an_oak(name):
    """
    Determine whether a speices is in the Genus 'Quercus'

    Parameters
    ----------
    name : str
        The speices name

    Returns
    -------
    bool
        Whether the speices is within the Quercus genus


    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('QuercAs 123')
    '\n***THIS LOOKS LIKE A TYPO***\n'
    False

    >>> is_an_oak('QuercusX abc')
    '\n***THIS LOOKS LIKE A TYPO***\n'
    False

    >>> is_an_oak('QuErCuS abc')
    True

    >>> is_an_oak('quercus xyz')    
    True
    """

    if name.split(' ')[0].lower() == 'quercus':
        return True

    # determine whether genus name has a string distance <2 from quercus, which may indicate a typo
    # elif stringdist.rdlevenshtein(name.split(' ')[0].lower(), 'quercus') <= 2:
    #     print('\n***THIS LOOKS LIKE A TYPO***\n')
    #     return False

    else:
        return False

def main(argv):
    """ Main entry point for program when called from terminal """

    # open io files
    f = open('../Data/TestOaksData.csv','r')
    g = open('../Results/JustOaksData.csv','w')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    # write header line to output file
    csvwrite.writerow(['Genus', 'species'])
    oaks = set()

    # print result for each species in input file, and write each oak to output file
    for row in taxa:
        if row[0] != 'Genus':
            print(row[0] + ' ' + row[1])
            print ("The genus is: ") 
            print(row[0] + '\n')
            if is_an_oak(row[0]):
                print('FOUND AN OAK!\n')
                csvwrite.writerow([row[0], row[1]])    

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
*** INSTALL AND IMPORT stringdist FOR TYPO DETECTION ***


Quercus  robur
The genus is: 
Quercus

FOUND AN OAK!

Fraxinus  excelsior
The genus is: 
Fraxinus

Pinus  sylvestris
The genus is: 
Pinus

Quercus  cerris
The genus is: 
Quercus

FOUND AN OAK!

Quercus  petraea
The genus is: 
Quercus

FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.04250s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
## Finds just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur',
         'Fraxinus excelsior',
         'Pinus sylvestris',
         'Quercus cerris',
         'Quercus petraea',
       ]

def is_an_oak(name):
    """returns whether a a species is within the oak genus"""
    return name.lower().startswith('quercus ')

##Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)


##Using list comprehensions   
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

##Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

##Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'Quercus robur', 'Quercus petraea', 'Quercus cerris'}
{'QUERCUS ROBUR', 'QUERCUS PETRAEA', 'QUERCUS CERRIS'}
{'QUERCUS ROBUR', 'QUERCUS PETRAEA', 'QUERCUS CERRIS'}

**********************************************************************

Code ran without errors

Time consumed = 0.02995s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
# FOR loops in Python
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total = total + s
    print(total)

# WHILE loops  in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")
# ctrl + c to stop!
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 84.0

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.29355s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Script demonstrating the __name_- environment variable"""

__appname__ = 'using_name.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public'

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')

print("This module's name is ", __name__)**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself
This module's name is  __main__

**********************************************************************

Code ran without errors

Time consumed = 0.08366s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************

"""
Sequence aligner. Finds best sequence alignment (without indels) between two sequences in ../Data/sequences.csv,
writing results to ../Results/best_align.csv and printing to terminal
"""

__appname__ = 'align_seqs.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

import csv
import sys
# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):
    """
    Calculate the alignment score for a pair of sequences and a startpoint for the shorter sequence.
    
    Parameters
    ----------
    s1 : str
        the longer of the two sequences to align

    s2 : str
        the shorter of the two sequences to align

    l1 : int
        the length of the longer sequence

    l2 : int
        the length of the shorter sequence

    startpoint : int
        the position at which the shorter sequence should be placed
        for this alignment calculation

    Returns
    -------
    score : int
        number of matching base positions for this alignment

    matched : str
        per base alignment



    >>> calculate_score('ATCGATCG','TCGATCG',8,7,0)
    0, '-------'

    >>> calculate_score('ATCGTCG','TCGATCG',7,7,1)
    3, '***---'
    """

    matched = "" # to hold string displaying alignements
    score = 0


    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score) 
    print(" ")

    return score, matched



# Two example sequences to match

def main(argv): 
    """ Main entry point for program when called from terminal """


    f = open('../Data/sequences.csv','r')

    csvread = csv.reader(f)
    sequences = []

    for row in csvread:
        sequences.append(row[0])

    seq1, seq2 = sequences[0],sequences[1]

    # Assign the longer sequence s1, and the shorter to s2
    # l1 is length of the longest, l2 that of the shortest

    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths


    # now try to find the best match (highest score) for the two sequences
    my_best_align = None
    my_best_match = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z,match = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2 # think about what this is doing!
            my_best_match = "." * i + match
            my_best_score = z 


    # write the best alignment to an output file

    g = open('../Results/best_align.txt', 'w')
    g.write("\n".join([my_best_match, my_best_align, s1, "Best score: " + str(my_best_score)]))

    # print the best alignment to terminal
    print('\nBEST MATCH:\n')
    print(my_best_match)
    print(my_best_align)
    print(s1)
    print("Best score:", my_best_score,'\n')

    return 0

if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)


**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
*---*---
ATCGATCG
AAAAAAGATAAAA
2
 
.*---*---
.ATCGATCG
AAAAAAGATAAAA
2
 
..*-------
..ATCGATCG
AAAAAAGATAAAA
1
 
...*--***--
...ATCGATCG
AAAAAAGATAAAA
4
 
....*-------
....ATCGATCG
AAAAAAGATAAAA
1
 
.....*---*---
.....ATCGATCG
AAAAAAGATAAAA
2
 
......----*--
......ATCGATCG
AAAAAAGATAAAA
1
 
.......**--*-
.......ATCGATCG
AAAAAAGATAAAA
3
 
........----*
........ATCGATCG
AAAAAAGATAAAA
1
 
.........*---
.........ATCGATCG
AAAAAAGATAAAA
1
 
..........*--
..........ATCGATCG
AAAAAAGATAAAA
1
 
..........
**********************************************************************

Code ran without errors

Time consumed = 0.05121s

======================================================================
Inspecting script file basic_io2.py...

File contents are:
**********************************************************************

#############################
# FILE OUTPUT
#############################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../sandbox/testout.txt','w')
for i in list_to_save:
    f.write(str(i) + '\n') ## Add a new line at the end

f.close()
**********************************************************************

Testing basic_io2.py...

basic_io2.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 83.0

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error (or warning):
Traceback (most recent call last):
  File "basic_io2.py", line 8, in <module>
    f = open('../sandbox/testout.txt','w')
FileNotFoundError: [Errno 2] No such file or directory: '../sandbox/testout.txt'

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Script demonstrating how to access command line arguments in a python program """

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: " , str(sys.argv))**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.04428s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************


"""
Sequence aligner. Finds best sequence alignment (without indels) between two sequences provided
from the command line in the form:

python3 align_seqs_fasta seq1.fasta seq2.fasta

Alternatively, if no command line args are provided, default fasta sequences will be used.
Results are written to ../Results/best_align_fasta.csv.
"""

__appname__ = 'align_seqs_fasta.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

import csv
import sys
# A function that computes a score by returning the number of matches starting
# from arbitrary startpoint (chosen by user)
def calculate_score(s1, s2, l1, l2, startpoint):

    """
    Calculate the alignment score for a pair of sequences and a startpoint for the shorter sequence.
    
    Parameters
    ----------
    s1 : str
        the longer of the two sequences to align

    s2 : str
        the shorter of the two sequences to align

    l1 : int
        the length of the longer sequence

    l2 : int
        the length of the shorter sequence

    startpoint : int
        the position at which the shorter sequence should be placed
        for this alignment calculation

    Returns
    -------
    score : int
        number of matching base positions for this alignment

    matched : str
        per base alignment



    >>> calculate_score('ATCGATCG','TCGATCG',8,7,0)
    0, '-------'

    >>> calculate_score('ATCGTCG','TCGATCG',7,7,1)
    3, '***---'
    """

    matched = "" # to hold string displaying alignements
    score = 0


    for i in range(l2):
        if (i + startpoint) < l1:
            if s1[i + startpoint] == s2[i]: # if the bases match
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # # some formatted output
    # print("." * startpoint + matched)           
    # print("." * startpoint + s2)
    # print(s1)
    # print(score) 
    # print(" ")

    return score, matched



# Two example sequences to match

def main(argv):
    """ Main entry point for program when called from terminal """

    # determine whether command line args are provided correctly.
    if len(argv) == 1:
        print('Using default .fasta files: 407228326.fasta, 407228412.fasta')
        f1 = open('../Data/fasta/407228326.fasta','r')
        f2 = open('../Data/fasta/407228412.fasta','r')
    

    elif len(argv) == 2 or len(argv) > 3:
        print('Please provide two fasta files to align. Otherwise, provide no files to use default .fasta files.')
        return 1


    elif len(argv) == 3:
        print('Using provided fatsa files: ', argv[1], argv[2] )
        f1 = open('../Data/fasta/' + argv[1],'r')
        f2 = open('../Data/fasta/' + argv[2],'r')

    # read sequences from fasta.

    csvread1 = csv.reader(f1)
    seq1_list = []

    for row in csvread1:
        seq1_list.append(row[0])

    csvread2 = csv.reader(f2)
    seq2_list = []

    for row in csvread2:
        seq2_list.append(row[0])

    seq1 = ''.join(s for s in seq1_list[1:])
    seq2 = ''.join(s for s in seq2_list[1:])

    # Assign the longer sequence s1, and the shorter to s2
    # l1 is length of the longest, l2 that of the shortest

    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths


    # now try to find the best match (highest score) for the two sequences
    my_best_align = None
    my_best_match = None
    my_best_score = -1

    for i in range(l1): # Note that you just take the last alignment with the highest score
        z,match = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_match = "." * i + match
            my_best_align = "." * i + s2 # think about what this is doing!
            my_best_score = z
        if i%1000 == 0:
            print(str(i) + ' / ' + str(l1) + ' comparisons complete')


    # write results to file

    g = open('../Results/best_align_fasta.txt', 'w')
    g.write("\n".join([my_best_match, my_best_align, s1,"Best score:\t" + str(my_best_score), "Lengths:\t" + str(l1), str(l2)]))

    # sequences too ong to meaningfully print to terminal
    # print(my_best_align)
    # print(s1)
    # print("Best score:", my_best_score)

    return 0

if __name__ == '__main__':
    status = main(sys.argv)
    sys.exit(status)**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Using default .fasta files: 407228326.fasta, 407228412.fasta
0 / 8849 comparisons complete
1000 / 8849 comparisons complete
2000 / 8849 comparisons complete
3000 / 8849 comparisons complete
4000 / 8849 comparisons complete
5000 / 8849 comparisons complete
6000 / 8849 comparisons complete
7000 / 8849 comparisons complete
8000 / 8849 comparisons complete

**********************************************************************

Code ran without errors

Time consumed = 5.79850s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Program which finds divisors to demonstrate control flow."""

__appname__ = 'control_flow.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

## imports

import sys

## constants

## functions

def even_or_odd(x=0):
    """find whether a value x is even or odd"""
    if x % 2 == 0:
        return '%d is Even' %x
    return '%d is Odd' %x

def largest_divisor_five(x=10):
    '''find which is the largest diviosr of x amongst 2,3,4,5.'''
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: #means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2, x): #  "range" returns a sequence of integers
        if x % i == 0:
          print("%d is not a prime: %d is a divisor" % (x, i)) 
          return False
    print("%d is a prime!" % x)
    return True 

def find_all_primes(x=22):
    """Find all the primes up to x"""
    allprimes = []
    for i in range(2, x + 1):
      if is_prime(i):
        allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes), x))
    return allprimes


def main(argv):
    """ main entry point of program when called from terminal"""
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0



if __name__ == '__main__':
    '''ensures the main funtion is called from command line'''
    status = main(sys.argv)
    sys.exit(status)
    **********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even
33 is Odd
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is no
**********************************************************************

Code ran without errors

Time consumed = 0.03994s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Program which finds divisors to demonstrate control flow."""

__appname__ = 'test_control_flow.py'
__author__ = 'Sam Turner (sat19@ic.ac.uk)'
__version__ = '0.0.1'
__license__ = 'GNU public' 

## imports

import sys
import doctest
## constants

## functions

def even_or_odd(x=0):
    """
    find whether a value x is even or odd.

    Parameters 
    ----------
    x : int, float
        Number whose parity we will determine.

    Returns
    -------
    str
        '%x is Even' or '%x is Odd'

    >>> even_or_odd(10)
    '10 is Even'
    
    >>> even_or_odd(5)
    '5 is Odd'

    >>> even_or_odd('hello')
    'Please enter an int or float'
    
    if float value provided, nearest integer is used:
    >>> even_or_odd(3.2)
    '3 is Odd'
    """

    if type(x) != float and type(x) != int:
        return 'Please enter an int or float'

    # to make 'nearest integer is used' behaviour true.
    # if x % 2 == 0: 
    if round(x) % 2 == 0:
        return '%d is Even' %x
    return '%d is Odd' %x


def main(argv):
    """main entry point for program when called from command line"""
    print(even_or_odd(22))
    print(even_or_odd(33))
    return 0


if __name__ == '__main__':
    """ensures the main funtion is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even
33 is Odd

**********************************************************************

Code ran without errors

Time consumed = 0.11314s

======================================================================
Inspecting script file basic_io1.py...

File contents are:
**********************************************************************
###########################
# FILE INPUT
###########################
# Open a file for reading
f = open('../Sandbox/test.txt', 'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
    print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../Sandbox/test.txt', 'r')
for line in f:
    if len(line.strip()) > 0:
        print(line)

f.close()**********************************************************************

Testing basic_io1.py...

basic_io1.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 82.0

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line

First Line

Second Line

Third Line

Fourth Line


**********************************************************************

Code ran without errors

Time consumed = 0.04835s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 82.0

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!